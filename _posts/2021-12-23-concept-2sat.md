---
title:  "만족성 문제 / SAT"
excerpt: "불린 값 변수의 참과 거짓으로 구성된 식이 주어질 때, 그 식을 참으로 하는 변수의 조합이 있는지 찾아내는 문제. 2-SAT의 소개"

categories:
  - concept
tags:
  - [그래프, 2-SAT]

toc: true
toc_sticky: true
 
date: 2021-12-23
last_modified_at: 2021-12-23
---
📌 **알립니다!**<br>
이번에 작성되는 글은 **구종만, 『알고리즘 문제해결 전략2』, 인사이트(2012)**를 읽고 정리하는 글입니다.<br>
28장. 그래프의 깊이 우선 탐색 - SAT문제<br>
더 자세한 관련 문제와의 설명은 책에 더 상세하게 설명되어 있습니다.
{: .notice--info}

📌 **선수 지식**<br>
1 . \\(T \Rightarrow T\\) : True<br>
2 . \\(T \Rightarrow F\\) : False<br>
3 . \\(F \Rightarrow T\\) : True<br>
4 . \\(F \Rightarrow F\\) : True
{: .notice--warning}

# SAT문제
> SAT(Satisfiability problem, 충족 가능성 문제)는 어떠한 변수들로 이루어진 논리식이 주어졌을 때, 그 논리식이 참이 되는 변수 값이 존재하는지를 찾는 문제이다. 만족성 문제, 만족도 문제, 만족 문제, 불린 충족 가능성 문제라고도 부른다. - wikipedia

간단히 말해, 어떤 논리식이 주어졌을 때 그 논리식이 참이 되도록 만드는 변수의 조합을 찾는 문제이다. 다음 예시를 한 번 보자.
\begin{aligned}
    (!a\,||\, b)\, \&\&\, (!b\, ||\, c)\, \&\&\, (a\, ||\, c)\, \&\&\, (b\, ||\, c)\, \&\&\, c
\end{aligned}
위의 논리식을 참으로 만들기 위한 값은 여러가지가 있을 수 있지만, 그 중 하나로 a(false), b(false), c(true)로 설정하여 문제를 해결할 수 있다.

위의 식이 특별한 구조를 가지고 있음을 알 수 있는데, 이 식은 변수의 값이 `||`로 모여서 하나의 절이 만들어지고 각 절은 `&&`로 묶여져 있음을 알 수 있다. 이런 구조를 `논리곱 정규형`구조라고 부르는데, <u>어떠한 논리식도 적절한 전개를 거쳐 이 형태로 표현할 수 있다</u>.

<br>

# 2-SAT문제
방금까지 어떠한 논리식도 각 절들이 `&&`로 묶인 논리곱 정규형 형태로 재구성할 수 있다고 보았다. 그 중, 특별히 각 절에 최대 2개의 변수만 존재하는 논리식에 대해서 **2-SAT**문제라고 부른다.

## SAT와 2-SAT의 차이점
**SAT문제**는 아직 문제를 푸는데 있어서 빠른 방법을 찾지 못했다. SAT뿐만아니라 모든 `NP-complete`문제에 대해서 현재 존재하는 가장 빠른 방법은 입력의 크기의 지수에 비례하는 시간을 갖는다.

하지만, **2-SAT문제**는 SAT와 달리 그래프를 이용해 다항시간에 해결하는 것이 가능하다.

## 변수 함의 그래프의 생성
그렇다면 이제 2-SAT의 논리식을 그래프로 변경해서 풀어야 한다. 그래프로 변경하기 전에 먼저 각 절에는 최대 2개의 변수만 존재한다는 것을 이용한다. 예를 들어 다음과 같은 식을 보자.
\begin{aligned}
    (a || b)
\end{aligned}
위의 논리식을 보면, a와 b 둘 중 하나는 반드시 참이되어야 함을 알 수 있다. a가 거짓이라면 반드시 b가 참이어야하고, 반대로 b가 거짓이면 a는 참이되어야 한다. 이렇게 <u>P이면 Q이다</u>와 같은 형태의 관계를 필요·충분조건으로 표현할 수 있었고, 그 중앙에는 화살표로 이었었다.
\begin{aligned}
    !a \Rightarrow b \\\\\\
    !b \Rightarrow a
\end{aligned}
위의 표현대로 동일하게 그래프를 생성하면 된다. 이렇게 논리식에 포함된 변수들의 값에 대한 요구 조건을 표현한 그래프를 **함의 그래프(implication graph)**라고 부른다. 한 번 아래의 논리식을 직접 함의 그래프로 구성하여 그리는 과정을 살펴보자.
\begin{aligned}
    (!a\,||\, b)\, \&\&\, (!b\, ||\, c)\, \&\&\, (a\, ||\, c)\, \&\&\, (b\, ||\, c)
\end{aligned}
![image](https://user-images.githubusercontent.com/91870042/147192059-0f4cbf5a-47e6-400c-82d4-4f0f9efbef35.png){: .align-center}

### C++로 작성한 함의 그래프 생성
위의 필요·충분 조건을 그래프로 생성하기 위해서 다음과 같은 연산을 한다.

📍\\(X_i,\,\,!X_i\\)표현 방법<br>
\\(X_i\\)는 \\(2\times i\\) 정점으로 표현하고, \\(!X_i\\)는 \\(2\times i + 1\\)정점으로 표현한다.
{: .notice--success}

```cpp
for (int i = 0; i < n; i += 2) {
    int j = i + 1;
    adj[i * 2 + 1].push_back(j * 2);
    adj[j * 2 + 1].push_back(i * 2);
}
```

## 작성된 함의 그래프에서 답 찾아내기
답이되는 경우를 찾아내기 전에, 답이 되지 않는 경우를 제거하여서 만들어 보자. 먼저 답이 되지 않는 경우를 살펴보자. (a || b)가 거짓이라면 다음 2가지 간선이 거짓이라는 것과 동일하다.
- \\(!a \Rightarrow b\\)
- \\(!b \Rightarrow a\\)

\\(P \Rightarrow Q\\)에서 P가 참인데, Q가 거짓이라면 요구조건이 만족되지 않은 것이기 때문에, 다음 2가지 조건을 만족하도록 그래프 정점을 분류하는 것이 2-SAT의 문제를 해결하는 것과 동일하다.(글 상단, 선수 지식 참고)

1. 정점 쌍 \\(X_i\\)와 \\(!X_i\\)중 하나는 참, 하나는 거짓으로 분류되어야 한다.
2. 참 정점에서 거짓 정점으로 가는 경로가 존재하면 안된다.

하지만 모든 함의 그래프에 대해서 위의 2가지 조건을 만족하는 분류가 항상 존재하는 것은 아니다. 답이 존재하지 않는 함의 그래프의 예로는 <u>한 변수를 포함하는 두 정점이 하나의 사이클에 포함되어 있는 경우</u>이다. 조금 더 쉽게 말하자면, **한 사이클에 참 정점과 거짓 정점이 포함되면 답을 찾을 수 없다**.

## SCC를 이용한 풀이
한 사이클 내에 참 정점과 거짓 정점이 있는지 파악해야 하기 때문에, 그래프를 사이클로 묶어야할 필요가 있다. 

> 한 정점이 둘 이상의 사이클에 포함되어 있는 경우?

한 정점이 둘 이상의 사이클에 포함되어 있다는 것은 해당 사이클을 한 묶음으로 보면 그 묶음은 SCC가 된다는 것을 알 수 있다. 그렇기 위해서 이전에 알아본, `SCC(강 결합 컴포넌트)`를 이용하여 다시 **함의 그래프를 SCC단위로 묶는다**.

각 SCC에서 하나의 정점 (참, 거짓)이 모두 포함되어 있다면 전체가 거짓이된다. 반대로, 그러한 정점이 하나라도 없다면 논리식을 만족하는 변수의 조합이 하나 이상 있다고 할 수 있다.

### C++ SCC를 이용한 2-SAT문제 해결
```cpp
vector<int> solve2SAT() {
    int n = adj.size() / 2; // 변수의 개수
    // 함의 그래프의 정점들을 강결합 요소별로 묶는다.
    vector<int> label = tarjanSCC();
    // 이 SAT문제를 푸는 것이 불가능한지 확인한다. 한 변수를 나타내는 두 정점이
    // 같은 강결합 요소에 속해있는 경우 답이 존재할 수 없다.
    for (int i = 0; i < 2 * n; i += 2)
        if (label[i] == label[i + 1])
            return vector<int>();
    
    // SAT문제를 푸는 것이 가능하다.
    vector<int> value(2 * n, -1);
    // 타잔 알고리즘에서 SCC는 위상 정렬의 역순으로 배정된다.
    // SCC번호의 역순으로 각 정점을 정렬하면 위상 정렬의 순서가 된다.
    vector<pii> order;
    for (int i = 0; i < 2 * n; ++i)
        order.push_back({-label[i], i});
    sort(order.begin(), order.end());

    // 각 정점에 값을 배정한다.
    for (int i = 0; i < 2 * n; ++i) {
        int vertex = order[i].second;
        int variable = vertex / 2; // 2*i, 2*i + 1은 같은 정점을 가리킨다.
        int isTrue = vertext % 2 == 0;
        if (value[variable] != -1) continue; // 이미 배정이 완료
        // not A가 A보다 먼저 나왔으면 A는 참이다.
        // A가 not A보다 먼저 나왔으면 A는 거짓이다.
        value[variable] = !isTrue;
    }
    return value;
}
```
## 시간복잡도 분석
위의 알고리즘의 수행시간은 강결합 컴포넌트 분리 알고리즘에 지배된다. 그렇기 때문에 시간 복잡도는 \\(O(\|V\|+\|E\|)\\)이다.


