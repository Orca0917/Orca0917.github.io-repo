---
title:  "강결합 컴포넌트 / SCC"
excerpt: "SCC: Strongly Connected Components에 대한 이해와 타잔 알고리즘(Tarjan's Algorithm) 설명."

categories:
  - concept
tags:
  - [Graph, Tarjan, SCC]

toc: true
toc_sticky: true
 
date: 2021-12-22
last_modified_at: 2021-12-22
---
📌 **알립니다!**<br>
이번에 작성되는 글은 **\<알고리즘 문제해결 전략2 - 구종만\>**를 읽고 정리하는 글입니다.<br>
28장. 그래프의 깊이 우선 탐색 - 강결합 컴포넌트 분리<br>
더 자세한 관련 문제와의 설명은 책에 더 상세하게 설명되어 있습니다.
{: .notice--info}

# 용어 SCC의 이해
방향 그래프 상에서 두 정점 u, v에 대해 **양 방향으로 가는 경로가 모두 있는 경우**에 두 정점 u, v는 같은 SCC에 속해있다고 말한다. 즉 정점 u에서 출발하여 정점v에 도달할 수 있고, 정점v에서 출발하여 정점u에 도달할 수 있는 경우 둘은 같은 집합에 속해있다고 보는 것이다. 아래 그림을 통해서 더 자세히 알아보자

<!-- 강결합 컴포넌트 분리 예시 사진 -->
![image](https://user-images.githubusercontent.com/91870042/147087147-312d3f82-353d-4129-bf5d-862af6f29837.png){: .align-center}

위의 사진에서 보면 a에서 e로 가는 경로가 있고, e에서 a로 가는 경로가 있기 때문에 a, e는 서로 같은 SCC에 속해있는 것을 볼 수 있다. 하지만, a와 c를 보게 되면 a → b → c 로 가는 경로는 존재하지만, c에서 a로 가는 경로는 없음을 알 수 있다.

## SCC와 사이클의 관계
SCC에서 관찰할 수 있는 또다른 점은, 하나의 SCC묶음을 하나의 정점으로 보게 된다면, 전체의 그래프는 DAG(Directed Acyclic Graph, 유향 비순환 그래프)임을 알 수 있다. SCC는 이처럼 사이클과 밀접하게 연결되어 있다. 한 사이클에 포함되는 정점들은 항상 같은 SCC에 속해 있게 된다.

## 현실에서 SCC의 사용
SCC는 이러한 개념을 현실에서 일방통행 도로에서의 상황속에서 이용될 수 있다. 예를 들어, 일방통행 도로만 있는 도시에서 SCC로 묶어 그 개수가 2개 이상의 SCC로 이루어져있다면, 하나의 지역에서 다른 지역으로 이동할 수 없다는 것을 의미하게 된다.

<br>

# 타잔(Tarjan) 알고리즘
이번에는 프로그램 상에서 SCC를 어떻게 구현할 수 있는지 알아보자. 가장 단순하게 생각해보면, 모든 정점 쌍에 대해서 DFS를 실행하여 서로 도달할 수 있는지만 판단하여 만들 수 있다. 하지만 이런 경우, \\(O(\|V\|\times \|E\|)\\)의 시간이 걸리게 되어 그래프가 커지면 사용할 수 없다. 강결함 컴포넌트 분리의 대표적 알고리즘인 `타잔 알고리즘 (Tarjan's Algorithm)`을 사용하면 한 번의 DFS로 모든 정점을 SCC별로 분리하는 것이 가능하다.

## 타잔 알고리즘과 스패닝 트리
먼저 임의의 정점부터 시작해 DFS를 수행하여 스패닝 트리를 생성해보자. 아래 그림은 위에서 설명한 그래프를 정점a를 기준으로 스패닝 트리를 생성한 것이다. 이 스패닝 트리를 적절하게 자르기만 해도 SCC를 만들 수 있는 것을 관찰할 수 있고 그것이 우연이 아님을 증명할 수 있다.

![image](https://user-images.githubusercontent.com/91870042/147091233-51e266cc-81b6-4787-8546-3ef36d75904d.png){: .align-center}

DFS가 어떤 SCC를 처음 방문했다고 하고 그 정점을 x라고 하자. 하나의 SCC에 속한 두 정점간에는 항상 경로가 있기 때문에, `dfs(x)`가 종료하기 전에 같은 SCC에 속한 정점을 모두 방문하게 된다. 따라서 이 SCC에 속한 정점들은 모두 x를 루트로 하는 서브트리에 저장이 된다.

![image](https://user-images.githubusercontent.com/91870042/147099612-23a9e249-63d7-4a8b-84ad-df90c2aa330f.png){: .align-center}

반대로, 스패닝 트리를 분리하여 SCC를 만들 수 없는 유일한 경우는 x와 같은 SCC에 속한 정점y 사이에 다른 정점z가 끼어 있는 경우이다. 그러나 이 경우, z → y, y → x로 가는 경로를 합치면, z → x로 가는 경로가 만들어진다. 그렇게 되면 z와 x는 같은 SCC에 속해야하며 원래의 가정이 모순된다.

## 타잔 알고리즘의 진행과정
타잔 알고리즘이 실행이 되면 **DFS를 이용하여 각 정점을 SCC로 묶는다**. 먼저 DFS로 만들어진 스패닝트리의 적절한 부분을 찾아서 끊어야 하는데 어떤 부분을 끊어야 할까?

어떠한 간선을 자르겠다고 해보자. 트리 간선 (u, v)를 자른다는 것은, v에서 u로 가는 경로가 없다는 뜻이다. 해당 간선을 자르기 위해서는 다음 2가지를 고려해야 한다.

1. 역방향 간선  
역방향 간선을 사용하는 이유는 v에서 u로 가는 경로에는 반드시 하나 이상의 역방향 간선이 필요하기 때문이다. `절단점`판단 알고리즘과 같이 v를 루트로 하는 서브트리를 탐색하면서 만나는 역방향 간선을 이용해 닿을 수 있는 가장 높은 점을 찾는다. 이 점이 u 이상의 정점이라면 이 역방향 간선을 통해 u에서 v로 갈 수 있다는 말이기 때문에 자르면 안된다.

2. 교차 간선  
절단점 판단 알고리즘에서는 무향그래프에 대해서만 판단을 했었기 때문에 교차간선에 대한 고려도 필요하다. 먼저, 역방향 간선으로만 판단하면 어떤일이 벌어지는지 보자.
    ![image](https://user-images.githubusercontent.com/91870042/147098216-c1e0be3f-1369-49b6-adfd-86e1ac88ad5e.png){: .align-center}
    위의 그래프에서 1번 정점을 기준으로 DFS를 실행했을 때, 1, 2, 3, 4를 방문하고, 5, 6을 방문하여 스패닝 트리를 생성했다고 하자. 스패닝 트리에서는 5번을 루트로하는 서브트리에서 그 부모인 1번 이상으로 가는 역방향 간선은 없지만, 교차간선(6, 4)를 이용하게 되면 1번으로 갈 수 있게 되어 간선(1, 5)를 끊어서는 안된다.

위와 같은 상황이 벌어지는 것을 방지해야하기 때문에 교차간선을 고려해야 한다. <u>하지만 주의해야 할 점은 교차간선이 존재한다고 해서, 항상 부모 노드로 갈 수 있는 것은 아니다.</u>

<br>

> 그렇다면 어떠한 교차간선을 이용해야 되나

그 판단하는 것은 미리 연산된 SCC정보를 활용된다. 아까와 같은 상황에서 6번 정점에서 4번 정점으로 교차간선을 통해서 이동했다고 하자. 4번 정점에서 1번정점을 가기 위해서는 그 **경로에 끊어진 부분이 존재해서는 안된다**. 끊어진 간선이 하나라도 존재하면 <u>별도의 SCC로 묶여 있음</u>을 의미한다. 그렇기 때문에 이미 해당 정점이 SCC로 묶여 있는지를 확인하면 교차간선을 통해 조상으로 이동할 수 있는지 확인할 수 있다.

정리하면 다음과 같다.

정점v를 루트로 하는 서브트리에서, v보다 먼저 발견된 정점으로 가는 역방향 간선이 있으면 해당 간선을 끊으면 안된다. 그런 역방향 간선이 없어도, v보다 먼저 발견되어 있으며 아직 SCC로 묶이지 않은 정점으로 가는 교차간선이 있으면 해당 간선을 끊어서는 안된다.
{: .notice--success}

## 타잔 알고리즘 C++ 코드
```cpp
// 그래프의 인접리스트 표현
vector<vector<int>> adj;
// 각 정점의 컴포넌트 번호. 컴포넌트의 번호는 0부터 시작되고
// 같은 컴포넌트 끼리는 번호가 동일하다.
vector<int> sccId;
// 각 정점의 발견순서
vecor<int> discovered;
// 정점의 번호를 담는 스택 > 같은 컴포넌트 끼리 묶을 때 사용
stack<int> st;
int sccCounter, vertexCounter;

// here를 루트로 하는 서브트리에서 역방향 간선이나 교차간선을
// 통해 갈 수 있는 정점 중 최소 발견 순서를 반환한다.
// (이미 SCC로 묶인 정점으로 연결된 교차간선은 무시한다.)
int scc(int here) {
    int ret = discovered[here] = vertexCounter++;

    st.push(here);
    for (int i = 0; i < adj[here].size(); ++i) {
        int there = adj[here][i];
        // (here, there)이 트리 간선인 경우
        if (discovered[there] == -1)
            ret = min(ret, scc(there));
        // there이 무시해야 하는 교차간선이 아닌 경우
        else if (sccId[there] == -1)
            ret = min(ret, discovered[there]);
    }

    // here에서 부모로 올라가는 간선인지 확인한다.
    if (ret == discovered[here]) {
        // here을 루트로 하는 서브트리에서 아직 SCC에 포함되지
        // 않은 정점들을 하나의 컴포넌트로 묶는다.
        while (true) {
            int t = st.top();
            st.pop();
            sccId[t] = sccCounter;
            if (t == here) break;
        }
        ++sccCounter;
    }
    return ret;
}

vector<int> tarjanSCC() {
    sccID = discovered = vector<int>(adj.size(), -1);
    sccCounter = vertexCounter = 0;
    for (int i = 0; i < adj[i].size(); ++i) if (discovered[i] == -1) scc(i);
    return sccId;
}
```

### 스택의 사용
위에서 here노드에서 그 부모로 올라가는 간선을 끊었을 때, here의 서브트리에 속한 정점들을 하나의 SCC로 묶기 위해서 스택을 사용하였다. 해당 스택은 지금까지 방문한 정점 중 아직 SCC로 묶이지 않은 모든 정점을 가지고 있다. 각 정점을 처음 방문할때, push가 일어나기 때문에 here위에 있는 정점들은 here의 후손이면서 아직 다른 SCC로 묶이지 않은 정점이다.

## 시간복잡도
`scc()`가 DFS와 다른 것은 스택에서 정점을 꺼내는 반복문 뿐인데, 분할 상환 분석을 이용하면, 반복문의 총 횟수가 \\(O(\|V\|)\\)인 것을 알 수 있다. 따라서 해당 알고리즘의 시간복잡도는 \\(O(\|V\| + \|E\|)\\)가 된다.

## 위상정렬
위의 코드에서 새로운 SCC가 생성되는 부분은, `scc()`가 종료되기 바로 이전이다. 그렇기 때문에, 각 SCC는 위상 정렬의 역순으로 번호가 매겨진다. 이 속성을 이용해 그래프의 압축을 구현하지 않고 간단히 문제를 해결할 수 있는 경우가 존재하기 때문에 알아두면 좋다.