---
title:  "[C++] 백준 6549: 히스토그램에서 가장 큰 직사각형"
excerpt: "플래티넘 Ⅴ"

categories:
  - boj
tags:
  - [C++, 알고리즘, 자료구조, 세그먼트 트리, 분할 정복, 스택]
toc: true
toc_sticky: true
 
date: 2022-01-10
last_modified_at: 2022-01-10
---
📌 **알립니다!**<br>
문제 난이도의 분류와 출처는 BOJ와 Solved.ac에 있습니다.
{: .notice--info}

# 1. 문제 출처
[<img src="https://static.solved.ac/tier_small/16.svg" style="width: 1em"> 백준_6549_히스토그램에서 가장 큰 직사각형](https://www.acmicpc.net/problem/6549)

<br>

# 2. 문제 해설 & 분류
이 문제는 세그먼트 트리, 분할정복, 스택을 이용한 풀이들이 존재하는데 이번에는 **스택**을 이용해서 문제를 해결하였다. 정확히는 **스위핑 알고리즘**과의 결합인데, 스택을 이용한 풀이를 생각하기 어려워서 책을 보고 문제풀이를 진행했다.

![image](https://user-images.githubusercontent.com/91870042/148715402-349be6bf-2330-4d0a-a984-565f96a395ca.png){: .align-center}

하나의 예시로 위와 같은 히스토그램이 있다고 가정해보자. 그랬을 때, 위의 히스토그램에서 가장 큰 직사각형은 노란색 사각형임을 알 수 있다. 그 때의 특징은 다음 2가지를 뽑아낼 수 있다.
1. 가장 큰 직사각형의 크기는 사각형의 너비에 포함된 히스토그램 중 가장 낮은 높이이다.
2. 가장 큰 직사각형의 양 옆은 위의 높이보다 낮은 판자로 감싸져있다.

위의 2가지를 만족하면 히스토그램에서 사각형 중 최대 넓이들을 확인할 수 있다. 이제 여기서 조금더 일반화하기 위해, \\(i\\)번째 히스토그램 사각형을 높이로 하는 가장 넓은 직사각형을 구하기로 해보자. 그리고, **\\(i\\)보다 낮은 것이 처음 등장하는 양 옆의 히스토그램 사각형의 위치를 \\(\text{left[i]}\\), \\(\text{right[i]}\\) 라고 표현**할 것이다.  
그렇다면, 너비는 \\(\text{right[i]} - \text{left[i]} -1\\)이 되고, 사각형의 넓이는 너비에 \\(h[i]\\)를 곱한 값이 될 것이다.

> left[i], right[i]를 어떻게 효율적으로 구해야 할까

여기서 스위핑 기법이 사용된다. 가장 처음 0번째 히스토그램의 left값, 즉 left[0]은 아무 히스토그램도 없기 때문에 -1이라고 둔다. 
```cpp
left[0] = -1;
```
이후 1번째 히스토그램부터 그 왼쪽에 있는 히스토그램과 비교를 진행할 것이다. 각각의 높이를 h[0], h[1]이라고 하면, 다음 3가지 경우가 존재한다. 

- h[0] > h[1]  
이 경우, 0번째 히스토그램의 오른쪽을 1번째 히스토그램이 막고 있다고 표현할 수 있다. 그렇기 때문에 \\(\text{right[0] = 1}\\) 이다. 현재, left[0], right[0]을 모두 알고 있기 때문에 사각형의 넓이를 계산하는 것이 가능하다. 더 나아가, 이 사각형의 넓이를 계산하면 0번째 히스토그램은 더 이상 연산에서 사용이 되지 않는다. 1번째 히스토그램이 더 낮기 때문에 그 이전에 가로 막힌다는 뜻이다. 따라서 0번째 히스토그램을 기록에서 지워버린다. 이어서, left[1]은 -1로 업데이트 해줘야 한다.
- h[0] < h[1]  
1번 히스토그램의 왼쪽을 0번째 히스토그램이 막고 있기 때문에, left[1] = 0이라고 할 수 있다. 하지만, right에 대해서는 아직 알 길이 없기 때문에 그냥 내버려둔다.
- h[0] = h[1]  
두 히스토그램의 높이가 정확히 동일한 경우, 왼쪽의 히스토그램을 굳이 계속 가지고갈 필요가 없다. 그렇기 때문에 첫번째 경우와 동일하게 왼쪽에 있는 히스토그램을 제거한다.

이제 위에서 살펴본 과정을 일반화 해서 적어보자.  
<u>i번째 히스토그램에 대해서, 왼쪽에 자신보다 높은 히스토그램만 남아 있으면, 그들의 최대 사각형을 자신이 막고 있는 것이다.</u> 따라서 왼쪽에 있는 최대 사각형의 넓이를 계산하고, i보다 큰 히스토그램을 스택에서 지워버린다. 이 과정을 거치면 i번째 히스토그램 왼쪽에는 i보다 낮은 높이의 히스토그램만 남게 된다. 다시 말해, left[i]를 알 수 있게 된다.

<br>

# 3. 정답 코드

~~~cpp
#include <bits/stdc++.h>
#define ll long long
#define pii pair<int, int>

using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    
    int n;
    while (cin >> n && n) {
        vector<ll> H(n);
        for (ll &h : H) cin >> h;

        // 가장 오른쪽에 높이가 0인 히스토그램이 있다고 가정한다.
        H.push_back(0); 

        ll result = 0;
        stack<ll> st;

        for (int i = 0; i < (int)H.size(); ++i) {

            // 내 왼쪽에 나보다 큰(이상) 히스토그램이 존재하는 경우
            while (!st.empty() && H[st.top()] >= H[i]) {

                // H[j]를 높이로 하는 최대 직사각형 넓이를 구하고, 제거한다.
                ll j = st.top(); st.pop();
                ll width = -1;

                if (st.empty()) width = i;
                else width = i - st.top() - 1;

                result = max(result, H[j] * width);
            }

            // 스택에 삽입된 원소는 그 높이가 계속 증가하게 들어가 있다.
            st.push(i);
        }
        cout << result << "\n";
    }
    
    return 0;
}
~~~

<br>

# 4. 관련 문제
[<img src="https://static.solved.ac/tier_small/18.svg" style="width: 1em"> 백준_11873_최대 직사각형](https://www.acmicpc.net/problem/11873)

<br>

# 5. 참고
구종만, 『알고리즘 문제해결 전략2』, 인사이트(2012)  
19장. 큐와 스택, 데크 - 3. 스택과 큐의 활용 中 스택을 이용한 울타리 자르기 문제의 해법