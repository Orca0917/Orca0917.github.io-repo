---
title:  "상호 배타적 집합 / union-find"
excerpt: "md 파일에 마크다운 문법으로 작성하여 Github 원격 저장소에 업로드 해보자. 에디터는 Visual Studio code 사용! 로컬 서버에서 확인도 해보자. "

categories:
  - Blog
tags:
  - [Blog, jekyll, Github, Git]

toc: true
toc_sticky: true
 
date: 2021-12-02
last_modified_at: 2021-12-02
---

# 도입
*union-find* 알고리즘은 어떠한 두 집합간의 **합 연산**을 할때 매우 유용하게 사용되는 알고리즘이다. 이를 사용하기 위해서 두 집합에는 공통된 원소들이 있어서는 안되며 **상호 배타적**이어야 한다. 이를 다른 말로  *disjoint set* 이라 하기도 한다. 

다시 말해, 공통된 원소가 없는 A집단과 B집단이 있다고 할 때, 기존에 서로 다른 집단이지만 같은 집단에 속하도록 효율적으로 변경하는 것이 *union-find* 이다. 이런 *union-find* 알고리즘에는 3가지 연산이 존재하며 그 중 핵심이 되는 연산은 2가지이다.

- `초기화` : \\(n\\)개의 원소가 **각각의 집합에 포함되어 있도록 초기화**한다.
- `합치기` : 두 원소 \\(a\\)와 \\(b\\)가 주어졌을 때, 이들이 속한 **두 집합을 하나로 합치는 연산**이다. 물론 두 원소는 같은 집합에 속해있을 수도 있다.
- `찾기` : 어떤 원소 \\(a\\)가 주어졌을 때, 이 **원소가 속한 집합을 찾는 연산**이다.

# 집합을 표현하는 방법 - 배열

가장 먼저 집합을 표현하고자 했을 때, 단순하게 생각나는 것은 원소의 크기만큼 배열을 두고 해당 원소가 속한 집합을 그 값으로 지정하는 것이다.

 `belongsTo[x] = k` : 원소 \\(x\\)는 집합\\(k\\)에 속해있다.

그렇다면, 집합 $k$에 있는 모든 원소를 집합\\(t\\)로 옮기고 싶을 때, 우리는 모든 원소를 순회하며 그 집합이 \\(k\\)이었다면 \\(t\\)로 변경하는 과정을 거쳐야한다. **이때의 시간복잡도는 원소의 개수가 \\(n\\)이라고 했을 때,  \\(O(n)\\)으로 표현**할 수 있다. 

# 집합을 표현하는 방법 - 트리

하지만, 합치는 연산을 매우 자주 사용되기 때문에 이보다 더 좋은 방법을 찾아야 한다. 이때 사용할 수 있는 방법이 **트리를 이용한 집합의 표현**이다. 

한 집합에 속하는 원소들을 하나의 트리로 묶어서 같은 집합임을 보여주는 것이다. 그래프로도 표현할 수 있지만, 트리로 표현했을 때의 장점은 **해당 집합의 대표값을 루트로 설정**할 수 있는 점이다.

![그림1. 트리를 이용한 집합의 표현](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/30d28ae2-2154-45f9-bf52-27e2bd805873/Untitled.png)

그림1. 트리를 이용한 집합의 표현

[그림1] 에서 0이 속하는 집합의 대표는2이고, 2가 속하는 집합의 대표가 2임을 알 수 있다. 이런 찾기 연산을 구현하기 위해서는 각 원소마다 자신의 부모가 누구인지 알고있어야 한다. 하지만 부모에서 자식으로 내려갈 일은 없기 때문에 자식에 대한 값은 알 필요가 없다.

이를 알면, 합치기 연산도 간단하게 할 수 있다. 각 집합의 대표 원소를 찾은 후에 한쪽 원소를 다른 한쪽의 자식노드로 넣으면 된다. 다음은 두 집합에 대해서 합치기 연산을 수행한 결과를 보여준다.

![그림2. 분리된 집합](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c26b80ce-ced2-43ee-91b9-70c714ae5f82/Untitled.png)

그림2. 분리된 집합

![그림3. 분리된 집합에서 합치기 연산을 수행한 결과](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/60bc06c0-5259-4366-bbf1-e5d98b7185a8/Untitled.png)

그림3. 분리된 집합에서 합치기 연산을 수행한 결과

# union-find의 구현과 평가(1)

```cpp
struct NaiveDisjointSet {
    vector<int> parent;
    NaiveDisjointSet(int n): parent(n) {
        for (int i = 0; i < n;+ ++i) parent[i] = i;
    }

    int find(int u) const {
        if (u == parent[u]) return u;
        else find(parent[u]);
    }

    void merge(int u, int v) {
        u = find(u), v = find(v);
        if (u == v) return;
        parent[u] = v;
    }
};
```

위의 코드에서 `find()` 를 실행하는데에는 **해당 트리의 높이에 비례하는 시간**이 걸리고, `merge()` 를 실행하는데에도 `find()` 가 지배하고 있기 때문에 같이 시간이 걸리게 된다. 

위의 코드는 전에 생각했던 배열을 이용한 구현보다 장점이 많아 보이지만, 트리가 한쪽으로 치우쳐진(기울어진)것에 대해서는 대책이 없다. 트리가 한쪽으로만 치우쳐져 있는 것은 **연결리스트와 같은 것**이므로 찾기, 합치기 모두 $O(n)$의 시간이 걸리게 되어 **배열을 사용한 구현보다 더 못한 결과가 발생**한다.

**최적화: *union-by-rank*와 *path compression***

이를 해결하기 위한 방법을 여러가지 방법이 있지만 가장 쉽게 생각할 수 있는 방법은 트리의 합치기 연산 수행 중, **트리의 높이가 더 낮은 것이 높은것의 자식으로 들어가는 방법**이다. 이러한 최적화 과정을 *`union-by-rank*최적화`라고 부른다.

여기에 추가로 `경로 압축` 최적화를 적용시킬 수 있다. 경로 압축 최적화는 현재 내 부모를 찾기 위해서 루트노드가 되기까지 나의 모든 부모를 모두 거쳐야만 했다. 이를 방지 하기 위해서 **현재 원소의 부모가 루트가 되도록 설정하는 것**이다. 이렇게 되면 특정 원소\\(x\\)의 부모를 찾는 시간복잡도는 \\(O(1)\\)이 된다.

# union-find의 구현과 평가(2)

```cpp
struct OptimizedDisjointSet {
    vector<int> parent, rank;
    OptimizedDisjointSet(int n): parent(n), rank(n, 1) {
        for (int i = 0; i < n;+ ++i) parent[i] = i;
    }

    int find(int u) const {
        if (u == parent[u]) return u;
        else return parent[u] = find(parent[u]);
    }

    void merge(int u, int v) {
        u = find(u), v = find(v);
        if (u == v) return;
        if (rank[u] > rank[v]) swap(u, v);
        parent[u] = v;
        if (rank[u] == rank[v]) ++rank[v];
    }
};
```

2가지 최적화를 모두 이용하면 트리의 높이는 두 트리의 높이가 같을 때만 증가하므로, 높이가 $h$인 트리가 생기기 위해서는 \\(h -1\\)인 두개의 트리가 합쳐져야 한다. 트리의 높이가 \\(h-1\\)이기 위해서 \\(x\\)개의 원소가 필요하다면 높이가 $h$인 트리를 생성하기 위해서는 원소가 \\(2\times x\\)개가 필요하다. 그렇기 때문에  **트리의 높이는 포함한 노드의 수의 \\(log\\)에 비례하며, 합치기 연산과 찾기연산의 시간복잡도는 \\(O(lgN)\\)이 된다.**

**최적화를 이용한 *union-find*의 시간복잡도 분석의 한계**

사실, 이 두가지 최적화를 모두 적용한 상호 배타적 집합의 수행시간을 분석하는 것은 매우 까다롭다. `find()` 연산은 호출할 때마다 수행 시간이 바뀌기 때문에 **분할상환분석**도 함께 이용해야한다. 찾기와 합치기 연산을 아주 여러번 수행하였을 때, 각 수행에 걸리는 시간은 애커만 함수에 따라 **모든 \\(n\\)의 크기에 대해 4이하의 시간(상수시간)이 걸린다**고 한다.

결론적으로 위의 2가지 최적화만 적용시켜도 **현실적인 모든 입력에 대해서는 상수 시간에 작동**한다고 봐도 된다.